var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import path from 'node:path';
import { pack } from '../../../core/packager.js';
import { logger, setLogLevelByWorkerData } from '../../../shared/logger.js';
import { Spinner } from '../../cliSpinner.js';
// Initialize logger configuration from workerData at module load time
// This must be called before any logging operations in the worker
setLogLevelByWorkerData();
function defaultActionWorker(task) {
    return __awaiter(this, void 0, void 0, function* () {
        // Handle ping requests for Bun compatibility check
        if ('ping' in task) {
            return {
                ping: true,
            };
        }
        // Validate task structure
        if (!task || typeof task !== 'object') {
            throw new Error(`Invalid task: expected object, got ${typeof task}`);
        }
        // At this point, task is guaranteed to be DefaultActionTask
        const { directories, cwd, config, cliOptions, stdinFilePaths } = task;
        if (!directories || !Array.isArray(directories)) {
            throw new Error('Invalid task: directories must be an array');
        }
        // Provide defaults for bundled environments where cliOptions might be undefined
        const safeCliOptions = cliOptions !== null && cliOptions !== void 0 ? cliOptions : {};
        logger.trace('Worker: Using pre-loaded config:', config);
        const spinner = new Spinner('Initializing...', safeCliOptions);
        spinner.start();
        let packResult;
        try {
            const { skillName, skillDir, skillProjectName, skillSourceUrl } = safeCliOptions;
            const packOptions = { skillName, skillDir, skillProjectName, skillSourceUrl };
            if (stdinFilePaths) {
                // Handle stdin processing with file paths from main process
                // File paths were already read from stdin in the main process
                logger.trace(`Worker: Processing ${stdinFilePaths.length} files from stdin`);
                // Use pack with predefined files from stdin
                packResult = yield pack([cwd], config, (message) => {
                    spinner.update(message);
                }, {}, stdinFilePaths, packOptions);
            }
            else {
                // Handle directory processing
                const targetPaths = directories.map((directory) => path.resolve(cwd, directory));
                packResult = yield pack(targetPaths, config, (message) => {
                    spinner.update(message);
                }, {}, undefined, packOptions);
            }
            spinner.succeed('Packing completed successfully!');
            return {
                packResult,
                config,
            };
        }
        catch (error) {
            spinner.fail('Error during packing');
            throw error;
        }
    });
}
export default defaultActionWorker;
// Export cleanup function for Tinypool teardown
export const onWorkerTermination = () => __awaiter(void 0, void 0, void 0, function* () {
    // Any cleanup needed when worker terminates
    // Currently no specific cleanup required for defaultAction worker
});
//# sourceMappingURL=defaultActionWorker.js.map