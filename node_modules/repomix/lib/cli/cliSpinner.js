import logUpdate from 'log-update';
import pc from 'picocolors';
// Replicate cli-spinners dots animation
const dotsFrames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
const dotsInterval = 80;
export class Spinner {
    constructor(message, cliOptions) {
        this.currentFrame = 0;
        this.interval = null;
        this.message = message;
        // If the user has specified the verbose flag, don't show the spinner
        // Use optional chaining to handle undefined cliOptions (e.g., in bundled worker environments)
        this.isQuiet = (cliOptions === null || cliOptions === void 0 ? void 0 : cliOptions.quiet) || (cliOptions === null || cliOptions === void 0 ? void 0 : cliOptions.verbose) || (cliOptions === null || cliOptions === void 0 ? void 0 : cliOptions.stdout) || false;
    }
    start() {
        if (this.isQuiet) {
            return;
        }
        const framesLength = dotsFrames.length;
        this.interval = setInterval(() => {
            this.currentFrame++;
            const frame = dotsFrames[this.currentFrame % framesLength];
            logUpdate(`${pc.cyan(frame)} ${this.message}`);
        }, dotsInterval);
    }
    update(message) {
        if (this.isQuiet) {
            return;
        }
        this.message = message;
    }
    stop(finalMessage) {
        if (this.isQuiet) {
            return;
        }
        if (this.interval) {
            clearInterval(this.interval);
            this.interval = null;
        }
        logUpdate(finalMessage);
        logUpdate.done();
    }
    succeed(message) {
        if (this.isQuiet) {
            return;
        }
        this.stop(`${pc.green('✔')} ${message}`);
    }
    fail(message) {
        if (this.isQuiet) {
            return;
        }
        this.stop(`${pc.red('✖')} ${message}`);
    }
}
//# sourceMappingURL=cliSpinner.js.map