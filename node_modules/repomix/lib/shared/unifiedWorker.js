/**
 * Unified Worker Entry Point
 *
 * This module serves as a single entry point for all worker types in Repomix.
 * It enables full bundling support by allowing the bundled file to spawn workers
 * using itself (import.meta.url), eliminating path resolution issues.
 *
 * When running as a worker, it dynamically imports the appropriate worker handler
 * based on the workerType specified in workerData.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { workerData } from 'node:worker_threads';
// Cache loaded handlers by worker type
const handlerCache = new Map();
/**
 * Dynamically load the appropriate worker handler based on workerType.
 * Uses dynamic imports to avoid loading all worker code when not needed.
 * Results are cached for reuse.
 */
const loadWorkerHandler = (workerType) => __awaiter(void 0, void 0, void 0, function* () {
    // Check cache first
    const cached = handlerCache.get(workerType);
    if (cached) {
        return cached;
    }
    let result;
    switch (workerType) {
        case 'fileCollect': {
            const module = yield import('../core/file/workers/fileCollectWorker.js');
            result = { handler: module.default, cleanup: module.onWorkerTermination };
            break;
        }
        case 'fileProcess': {
            const module = yield import('../core/file/workers/fileProcessWorker.js');
            result = { handler: module.default, cleanup: module.onWorkerTermination };
            break;
        }
        case 'securityCheck': {
            const module = yield import('../core/security/workers/securityCheckWorker.js');
            result = { handler: module.default, cleanup: module.onWorkerTermination };
            break;
        }
        case 'calculateMetrics': {
            const module = yield import('../core/metrics/workers/calculateMetricsWorker.js');
            result = { handler: module.default, cleanup: module.onWorkerTermination };
            break;
        }
        case 'defaultAction': {
            const module = yield import('../cli/actions/workers/defaultActionWorker.js');
            result = { handler: module.default, cleanup: module.onWorkerTermination };
            break;
        }
        default:
            throw new Error(`Unknown worker type: ${workerType}`);
    }
    // Cache the result
    handlerCache.set(workerType, result);
    return result;
});
/**
 * Infer worker type from task structure.
 * This is used in bundled environments where Tinypool may reuse child processes
 * across different worker pools.
 */
const inferWorkerTypeFromTask = (task) => {
    if (!task || typeof task !== 'object') {
        return null;
    }
    const taskObj = task;
    // defaultAction: has directories, cwd, config, cliOptions
    if ('directories' in taskObj && 'cwd' in taskObj && 'config' in taskObj) {
        return 'defaultAction';
    }
    // defaultAction ping task
    if ('ping' in taskObj) {
        return 'defaultAction';
    }
    // fileCollect: has filePath, rootDir, maxFileSize
    if ('filePath' in taskObj && 'rootDir' in taskObj && 'maxFileSize' in taskObj) {
        return 'fileCollect';
    }
    // fileProcess: has rawFile (nested object) and config
    if ('rawFile' in taskObj && 'config' in taskObj) {
        return 'fileProcess';
    }
    // calculateMetrics: has content, encoding (must check before securityCheck)
    if ('content' in taskObj && 'encoding' in taskObj) {
        return 'calculateMetrics';
    }
    // securityCheck: has filePath, content, type
    if ('filePath' in taskObj && 'content' in taskObj && 'type' in taskObj) {
        return 'securityCheck';
    }
    return null;
};
/**
 * Get workerType from workerData.
 * In Tinypool child_process mode, workerData is an array.
 */
const getWorkerTypeFromWorkerData = () => {
    if (!workerData) {
        return undefined;
    }
    // Handle array format (Tinypool child_process mode)
    if (Array.isArray(workerData)) {
        for (const item of workerData) {
            if (item && typeof item === 'object' && 'workerType' in item) {
                return item.workerType;
            }
        }
        return undefined;
    }
    // Handle object format (worker_threads mode)
    if (typeof workerData === 'object' && 'workerType' in workerData) {
        return workerData.workerType;
    }
    return undefined;
};
/**
 * Default export for Tinypool.
 * This function is called for each task and delegates to the appropriate handler.
 *
 * In bundled environments where Tinypool may reuse child processes across different
 * worker pools, we use task-based inference to determine the correct handler.
 */
export default (task) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    // Determine worker type: try workerData/env first, then infer from task
    let workerType = (_a = getWorkerTypeFromWorkerData()) !== null && _a !== void 0 ? _a : process.env.REPOMIX_WORKER_TYPE;
    // In bundled environments, Tinypool may reuse child processes.
    // If the task doesn't match the initially configured worker type, infer from task.
    const inferredType = inferWorkerTypeFromTask(task);
    // Use inferred type if available (more reliable in bundled env)
    if (inferredType) {
        workerType = inferredType;
    }
    if (!workerType) {
        throw new Error('Cannot determine worker type from workerData, env, or task structure');
    }
    // Load handler (cached)
    const { handler } = yield loadWorkerHandler(workerType);
    return handler(task);
});
/**
 * Cleanup function for Tinypool teardown.
 * Cleans up all cached handlers.
 */
export const onWorkerTermination = () => __awaiter(void 0, void 0, void 0, function* () {
    for (const { cleanup } of handlerCache.values()) {
        if (cleanup) {
            yield cleanup();
        }
    }
    handlerCache.clear();
});
//# sourceMappingURL=unifiedWorker.js.map