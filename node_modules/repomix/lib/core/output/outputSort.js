var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import fs from 'node:fs/promises';
import path from 'node:path';
import { logger } from '../../shared/logger.js';
import { getFileChangeCount, isGitInstalled } from '../git/gitRepositoryHandle.js';
// Cache for git file change counts to avoid repeated git operations
// Key format: `${cwd}:${maxCommits}`
const fileChangeCountsCache = new Map();
// Cache for git availability check per cwd
const gitAvailabilityCache = new Map();
const buildCacheKey = (cwd, maxCommits) => {
    return `${cwd}:${maxCommits !== null && maxCommits !== void 0 ? maxCommits : 'default'}`;
};
/**
 * Get file change counts from cache or git log.
 * Returns null if git is not available or the command fails.
 */
const getFileChangeCounts = (cwd, maxCommits, deps) => __awaiter(void 0, void 0, void 0, function* () {
    const cacheKey = buildCacheKey(cwd, maxCommits);
    // Check cache first
    const cached = fileChangeCountsCache.get(cacheKey);
    if (cached) {
        logger.trace('Using cached git file change counts');
        return cached;
    }
    // Check git availability (cached per cwd)
    const gitAvailable = yield checkGitAvailability(cwd, deps);
    if (!gitAvailable) {
        return null;
    }
    // Fetch from git log
    try {
        const fileChangeCounts = yield deps.getFileChangeCount(cwd, maxCommits);
        fileChangeCountsCache.set(cacheKey, fileChangeCounts);
        const sortedFileChangeCounts = Object.entries(fileChangeCounts).sort((a, b) => b[1] - a[1]);
        logger.trace('Git File change counts max commits:', maxCommits);
        logger.trace('Git File change counts:', sortedFileChangeCounts);
        return fileChangeCounts;
    }
    catch (_a) {
        return null;
    }
});
/**
 * Check if git is available in the given directory.
 * Results are cached per cwd.
 */
const checkGitAvailability = (cwd, deps) => __awaiter(void 0, void 0, void 0, function* () {
    const cached = gitAvailabilityCache.get(cwd);
    if (cached !== undefined) {
        return cached;
    }
    // Check if Git is installed
    const gitInstalled = yield deps.isGitInstalled();
    if (!gitInstalled) {
        logger.trace('Git is not installed');
        gitAvailabilityCache.set(cwd, false);
        return false;
    }
    // Check if .git directory exists
    const gitFolderPath = path.resolve(cwd, '.git');
    try {
        yield fs.access(gitFolderPath);
        gitAvailabilityCache.set(cwd, true);
        return true;
    }
    catch (_a) {
        logger.trace('Git folder not found');
        gitAvailabilityCache.set(cwd, false);
        return false;
    }
});
// Sort files by git change count for output
export const sortOutputFiles = (files_1, config_1, ...args_1) => __awaiter(void 0, [files_1, config_1, ...args_1], void 0, function* (files, config, deps = {
    getFileChangeCount,
    isGitInstalled,
}) {
    var _a, _b;
    if (!((_a = config.output.git) === null || _a === void 0 ? void 0 : _a.sortByChanges)) {
        logger.trace('Git sort is not enabled');
        return files;
    }
    const fileChangeCounts = yield getFileChangeCounts(config.cwd, (_b = config.output.git) === null || _b === void 0 ? void 0 : _b.sortByChangesMaxCommits, deps);
    if (!fileChangeCounts) {
        return files;
    }
    return sortFilesByChangeCounts(files, fileChangeCounts);
});
const sortFilesByChangeCounts = (files, fileChangeCounts) => {
    // Sort files by change count (files with more changes go to the bottom)
    return [...files].sort((a, b) => {
        const countA = fileChangeCounts[a.path] || 0;
        const countB = fileChangeCounts[b.path] || 0;
        return countA - countB;
    });
};
//# sourceMappingURL=outputSort.js.map