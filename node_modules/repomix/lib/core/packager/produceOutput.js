var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { withMemoryLogging } from '../../shared/memoryUtils.js';
import { generateOutput as generateOutputDefault } from '../output/outputGenerate.js';
import { generateSplitOutputParts } from '../output/outputSplit.js';
import { copyToClipboardIfEnabled as copyToClipboardIfEnabledDefault } from './copyToClipboardIfEnabled.js';
import { writeOutputToDisk as writeOutputToDiskDefault } from './writeOutputToDisk.js';
const defaultDeps = {
    generateOutput: generateOutputDefault,
    writeOutputToDisk: writeOutputToDiskDefault,
    copyToClipboardIfEnabled: copyToClipboardIfEnabledDefault,
};
export const produceOutput = (rootDirs_1, config_1, processedFiles_1, allFilePaths_1, gitDiffResult_1, gitLogResult_1, progressCallback_1, filePathsByRoot_1, ...args_1) => __awaiter(void 0, [rootDirs_1, config_1, processedFiles_1, allFilePaths_1, gitDiffResult_1, gitLogResult_1, progressCallback_1, filePathsByRoot_1, ...args_1], void 0, function* (rootDirs, config, processedFiles, allFilePaths, gitDiffResult, gitLogResult, progressCallback, filePathsByRoot, overrideDeps = {}) {
    const deps = Object.assign(Object.assign({}, defaultDeps), overrideDeps);
    const splitMaxBytes = config.output.splitOutput;
    if (splitMaxBytes !== undefined) {
        return yield generateAndWriteSplitOutput(rootDirs, config, processedFiles, allFilePaths, splitMaxBytes, gitDiffResult, gitLogResult, progressCallback, filePathsByRoot, deps);
    }
    return yield generateAndWriteSingleOutput(rootDirs, config, processedFiles, allFilePaths, gitDiffResult, gitLogResult, progressCallback, filePathsByRoot, deps);
});
const generateAndWriteSplitOutput = (rootDirs, config, processedFiles, allFilePaths, splitMaxBytes, gitDiffResult, gitLogResult, progressCallback, filePathsByRoot, deps) => __awaiter(void 0, void 0, void 0, function* () {
    const parts = yield withMemoryLogging('Generate Split Output', () => __awaiter(void 0, void 0, void 0, function* () {
        return yield generateSplitOutputParts({
            rootDirs,
            baseConfig: config,
            processedFiles,
            allFilePaths,
            maxBytesPerPart: splitMaxBytes,
            gitDiffResult,
            gitLogResult,
            progressCallback,
            filePathsByRoot,
            deps: {
                generateOutput: deps.generateOutput,
            },
        });
    }));
    progressCallback('Writing output files...');
    yield withMemoryLogging('Write Split Output', () => __awaiter(void 0, void 0, void 0, function* () {
        for (const part of parts) {
            const partConfig = Object.assign(Object.assign({}, config), { output: Object.assign(Object.assign({}, config.output), { stdout: false, filePath: part.filePath }) });
            // eslint-disable-next-line no-await-in-loop
            yield deps.writeOutputToDisk(part.content, partConfig);
        }
    }));
    return {
        outputFiles: parts.map((p) => p.filePath),
        outputForMetrics: parts.map((p) => p.content),
    };
});
const generateAndWriteSingleOutput = (rootDirs, config, processedFiles, allFilePaths, gitDiffResult, gitLogResult, progressCallback, filePathsByRoot, deps) => __awaiter(void 0, void 0, void 0, function* () {
    const output = yield withMemoryLogging('Generate Output', () => deps.generateOutput(rootDirs, config, processedFiles, allFilePaths, gitDiffResult, gitLogResult, filePathsByRoot));
    progressCallback('Writing output file...');
    yield withMemoryLogging('Write Output', () => deps.writeOutputToDisk(output, config));
    yield deps.copyToClipboardIfEnabled(output, progressCallback, config);
    return {
        outputForMetrics: output,
    };
});
//# sourceMappingURL=produceOutput.js.map