/**
 * Base abstract class providing common functionality for all parse strategies
 *
 * IMPORTANT: Strategy instances are shared across all files of the same language.
 * Strategies MUST be stateless - do not add instance variables or mutable state.
 * All data should come from method parameters only.
 */
export class BaseParseStrategy {
    /**
     * Helper method to get capture types from a capture name
     *
     * NOTE: Uses includes() intentionally to match hierarchical capture names.
     * Tree-sitter queries use captures like @name.definition.function for function names,
     * which should match 'definition.function'. This is not a bug but a design choice.
     *
     * @param name - The capture name to analyze (e.g., 'name.definition.function')
     * @param captureTypes - Object containing capture type constants
     * @returns Set of matching capture types
     */
    getCaptureTypes(name, captureTypes) {
        const types = new Set();
        for (const type of Object.values(captureTypes)) {
            // Uses includes() to match hierarchical names (e.g., 'name.definition.function' matches 'definition.function')
            if (name.includes(type)) {
                types.add(type);
            }
        }
        return types;
    }
    /**
     * Check if content has been processed and add it if not
     * @param content - The content to check
     * @param processedChunks - Set of already processed chunks
     * @returns true if content is new and was added, false if already processed
     */
    checkAndAddToProcessed(content, processedChunks) {
        const normalized = content.trim();
        if (processedChunks.has(normalized)) {
            return false;
        }
        processedChunks.add(normalized);
        return true;
    }
    /**
     * Validate that the line at startRow exists
     * @param lines - Array of file lines
     * @param startRow - Row to validate
     * @returns true if line exists, false otherwise
     */
    validateLineExists(lines, startRow) {
        return lines[startRow] !== undefined;
    }
    /**
     * Extract lines from a range and validate
     * @param lines - Array of file lines
     * @param startRow - Starting row
     * @param endRow - Ending row
     * @returns Array of selected lines, or null if invalid
     */
    extractLines(lines, startRow, endRow) {
        if (!this.validateLineExists(lines, startRow)) {
            return null;
        }
        const selectedLines = lines.slice(startRow, endRow + 1);
        return selectedLines.length > 0 ? selectedLines : null;
    }
    /**
     * Create a ParseResult with null content
     */
    createNullResult() {
        return { content: null };
    }
    /**
     * Create a ParseResult with content
     * @param content - The content to include
     * @param processedSignatures - Optional set of processed signatures
     */
    createResult(content, processedSignatures) {
        return { content, processedSignatures };
    }
}
//# sourceMappingURL=BaseParseStrategy.js.map