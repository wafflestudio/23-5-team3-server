var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { execFile } from 'node:child_process';
import fs from 'node:fs/promises';
import path from 'node:path';
import { promisify } from 'node:util';
import { RepomixError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';
const execFileAsync = promisify(execFile);
const GIT_REMOTE_TIMEOUT = 30000;
const gitRemoteEnv = Object.assign(Object.assign({}, process.env), { GIT_TERMINAL_PROMPT: '0' });
const gitRemoteOpts = { timeout: GIT_REMOTE_TIMEOUT, env: gitRemoteEnv };
export const execGitLogFilenames = (directory_1, ...args_1) => __awaiter(void 0, [directory_1, ...args_1], void 0, function* (directory, maxCommits = 100, deps = {
    execFileAsync,
}) {
    try {
        const result = yield deps.execFileAsync('git', [
            '-C',
            directory,
            'log',
            '--pretty=format:',
            '--name-only',
            '-n',
            maxCommits.toString(),
        ]);
        return result.stdout.split('\n').filter(Boolean);
    }
    catch (error) {
        logger.trace('Failed to get git log filenames:', error.message);
        return [];
    }
});
export const execGitDiff = (directory_1, ...args_1) => __awaiter(void 0, [directory_1, ...args_1], void 0, function* (directory, options = [], deps = {
    execFileAsync,
}) {
    try {
        const result = yield deps.execFileAsync('git', [
            '-C',
            directory,
            'diff',
            '--no-color', // Avoid ANSI color codes
            ...options,
        ]);
        return result.stdout || '';
    }
    catch (error) {
        logger.trace('Failed to execute git diff:', error.message);
        throw error;
    }
});
export const execGitVersion = (...args_1) => __awaiter(void 0, [...args_1], void 0, function* (deps = {
    execFileAsync,
}) {
    try {
        const result = yield deps.execFileAsync('git', ['--version']);
        return result.stdout || '';
    }
    catch (error) {
        logger.trace('Failed to execute git version:', error.message);
        throw error;
    }
});
export const execGitRevParse = (directory_1, ...args_1) => __awaiter(void 0, [directory_1, ...args_1], void 0, function* (directory, deps = {
    execFileAsync,
}) {
    try {
        const result = yield deps.execFileAsync('git', ['-C', directory, 'rev-parse', '--is-inside-work-tree']);
        return result.stdout || '';
    }
    catch (error) {
        logger.trace('Failed to execute git rev-parse:', error.message);
        throw error;
    }
});
export const execLsRemote = (url_1, ...args_1) => __awaiter(void 0, [url_1, ...args_1], void 0, function* (url, deps = {
    execFileAsync,
}) {
    validateGitUrl(url);
    try {
        const result = yield deps.execFileAsync('git', ['ls-remote', '--heads', '--tags', '--', url], gitRemoteOpts);
        return result.stdout || '';
    }
    catch (error) {
        logger.trace('Failed to execute git ls-remote:', error.message);
        throw error;
    }
});
export const execGitShallowClone = (url_1, directory_1, remoteBranch_1, ...args_1) => __awaiter(void 0, [url_1, directory_1, remoteBranch_1, ...args_1], void 0, function* (url, directory, remoteBranch, deps = {
    execFileAsync,
}) {
    validateGitUrl(url);
    if (remoteBranch) {
        yield deps.execFileAsync('git', ['-C', directory, 'init']);
        yield deps.execFileAsync('git', ['-C', directory, 'remote', 'add', '--', 'origin', url]);
        try {
            yield deps.execFileAsync('git', ['-C', directory, 'fetch', '--depth', '1', 'origin', remoteBranch], gitRemoteOpts);
            yield deps.execFileAsync('git', ['-C', directory, 'checkout', 'FETCH_HEAD']);
        }
        catch (err) {
            // git fetch --depth 1 origin <short SHA> always throws "couldn't find remote ref" error
            const isRefNotfoundError = err instanceof Error && err.message.includes(`couldn't find remote ref ${remoteBranch}`);
            if (!isRefNotfoundError) {
                // Rethrow error as nothing else we can do
                throw err;
            }
            // Short SHA detection - matches a hexadecimal string of 4 to 39 characters
            // If the string matches this regex, it MIGHT be a short SHA
            // If the string doesn't match, it is DEFINITELY NOT a short SHA
            const isNotShortSHA = !remoteBranch.match(/^[0-9a-f]{4,39}$/i);
            if (isNotShortSHA) {
                // Rethrow error as nothing else we can do
                throw err;
            }
            // Maybe the error is due to a short SHA, let's try again
            // Can't use --depth 1 here as we need to fetch the specific commit
            yield deps.execFileAsync('git', ['-C', directory, 'fetch', 'origin'], gitRemoteOpts);
            yield deps.execFileAsync('git', ['-C', directory, 'checkout', remoteBranch]);
        }
    }
    else {
        yield deps.execFileAsync('git', ['clone', '--depth', '1', '--', url, directory], gitRemoteOpts);
    }
    // Clean up .git directory
    yield fs.rm(path.join(directory, '.git'), { recursive: true, force: true });
});
export const execGitLog = (directory_1, maxCommits_1, gitSeparator_1, ...args_1) => __awaiter(void 0, [directory_1, maxCommits_1, gitSeparator_1, ...args_1], void 0, function* (directory, maxCommits, gitSeparator, deps = {
    execFileAsync,
}) {
    try {
        const result = yield deps.execFileAsync('git', [
            '-C',
            directory,
            'log',
            `--pretty=format:${gitSeparator}%ad|%s`,
            '--date=iso',
            '--name-only',
            '-n',
            maxCommits.toString(),
        ]);
        return result.stdout || '';
    }
    catch (error) {
        logger.trace('Failed to execute git log:', error.message);
        throw error;
    }
});
/**
 * Validates a Git URL for security and format
 * @throws {RepomixError} If the URL is invalid or contains potentially dangerous parameters
 */
export const validateGitUrl = (url) => {
    if (url.includes('--upload-pack') || url.includes('--config') || url.includes('--exec')) {
        throw new RepomixError(`Invalid repository URL. URL contains potentially dangerous parameters: ${url}`);
    }
    // Check if the URL starts with git@ or https://
    if (!(url.startsWith('git@') || url.startsWith('https://'))) {
        throw new RepomixError(`Invalid URL protocol for '${url}'. URL must start with 'git@' or 'https://'`);
    }
    try {
        if (url.startsWith('https://')) {
            new URL(url);
        }
    }
    catch (error) {
        // Redact embedded credentials in https URLs to avoid PII leakage
        const redactedUrl = url.startsWith('https://') ? url.replace(/^(https?:\/\/)([^@/]+)@/i, '$1***@') : url;
        logger.trace('Invalid repository URL:', error.message);
        throw new RepomixError(`Invalid repository URL. Please provide a valid URL: ${redactedUrl}`);
    }
};
//# sourceMappingURL=gitCommand.js.map