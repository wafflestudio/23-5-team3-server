var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import path from 'node:path';
import { logMemoryUsage, withMemoryLogging } from '../shared/memoryUtils.js';
import { collectFiles } from './file/fileCollect.js';
import { sortPaths } from './file/filePathSort.js';
import { processFiles } from './file/fileProcess.js';
import { searchFiles } from './file/fileSearch.js';
import { getGitDiffs } from './git/gitDiffHandle.js';
import { getGitLogs } from './git/gitLogHandle.js';
import { calculateMetrics } from './metrics/calculateMetrics.js';
import { produceOutput } from './packager/produceOutput.js';
import { validateFileSafety } from './security/validateFileSafety.js';
import { packSkill } from './skill/packSkill.js';
const defaultDeps = {
    searchFiles,
    collectFiles,
    processFiles,
    validateFileSafety,
    produceOutput,
    calculateMetrics,
    sortPaths,
    getGitDiffs,
    getGitLogs,
    packSkill,
};
export const pack = (rootDirs_1, config_1, ...args_1) => __awaiter(void 0, [rootDirs_1, config_1, ...args_1], void 0, function* (rootDirs, config, progressCallback = () => { }, overrideDeps = {}, explicitFiles, options = {}) {
    const deps = Object.assign(Object.assign({}, defaultDeps), overrideDeps);
    logMemoryUsage('Pack - Start');
    progressCallback('Searching for files...');
    const filePathsByDir = yield withMemoryLogging('Search Files', () => __awaiter(void 0, void 0, void 0, function* () {
        return Promise.all(rootDirs.map((rootDir) => __awaiter(void 0, void 0, void 0, function* () {
            return ({
                rootDir,
                filePaths: (yield deps.searchFiles(rootDir, config, explicitFiles)).filePaths,
            });
        })));
    }));
    // Sort file paths
    progressCallback('Sorting files...');
    const allFilePaths = filePathsByDir.flatMap(({ filePaths }) => filePaths);
    const sortedFilePaths = deps.sortPaths(allFilePaths);
    // Regroup sorted file paths by rootDir
    const sortedFilePathsByDir = rootDirs.map((rootDir) => ({
        rootDir,
        filePaths: sortedFilePaths.filter((filePath) => { var _a; return (_a = filePathsByDir.find((item) => item.rootDir === rootDir)) === null || _a === void 0 ? void 0 : _a.filePaths.includes(filePath); }),
    }));
    progressCallback('Collecting files...');
    const collectResults = yield withMemoryLogging('Collect Files', () => __awaiter(void 0, void 0, void 0, function* () {
        return yield Promise.all(sortedFilePathsByDir.map(({ rootDir, filePaths }) => deps.collectFiles(filePaths, rootDir, config, progressCallback)));
    }));
    const rawFiles = collectResults.flatMap((curr) => curr.rawFiles);
    const allSkippedFiles = collectResults.flatMap((curr) => curr.skippedFiles);
    // Get git diffs if enabled - run this before security check
    progressCallback('Getting git diffs...');
    const gitDiffResult = yield deps.getGitDiffs(rootDirs, config);
    // Get git logs if enabled - run this before security check
    progressCallback('Getting git logs...');
    const gitLogResult = yield deps.getGitLogs(rootDirs, config);
    // Run security check and get filtered safe files
    const { safeFilePaths, safeRawFiles, suspiciousFilesResults, suspiciousGitDiffResults, suspiciousGitLogResults } = yield withMemoryLogging('Security Check', () => deps.validateFileSafety(rawFiles, progressCallback, config, gitDiffResult, gitLogResult));
    // Process files (remove comments, etc.)
    progressCallback('Processing files...');
    const processedFiles = yield withMemoryLogging('Process Files', () => deps.processFiles(safeRawFiles, config, progressCallback));
    progressCallback('Generating output...');
    // Check if skill generation is requested
    if (config.skillGenerate !== undefined && options.skillDir) {
        const result = yield deps.packSkill({
            rootDirs,
            config,
            options,
            processedFiles,
            allFilePaths,
            gitDiffResult,
            gitLogResult,
            suspiciousFilesResults,
            suspiciousGitDiffResults,
            suspiciousGitLogResults,
            safeFilePaths,
            skippedFiles: allSkippedFiles,
            progressCallback,
        });
        logMemoryUsage('Pack - End');
        return result;
    }
    // Build filePathsByRoot for multi-root tree generation
    // Use directory basename as the label for each root
    // Fallback to rootDir if basename is empty (e.g., filesystem root "/")
    const filePathsByRoot = sortedFilePathsByDir.map(({ rootDir, filePaths }) => ({
        rootLabel: path.basename(rootDir) || rootDir,
        files: filePaths,
    }));
    // Generate and write output (handles both single and split output)
    const { outputFiles, outputForMetrics } = yield deps.produceOutput(rootDirs, config, processedFiles, allFilePaths, gitDiffResult, gitLogResult, progressCallback, filePathsByRoot);
    const metrics = yield withMemoryLogging('Calculate Metrics', () => deps.calculateMetrics(processedFiles, outputForMetrics, progressCallback, config, gitDiffResult, gitLogResult));
    // Create a result object that includes metrics and security results
    const result = Object.assign(Object.assign(Object.assign({}, metrics), (outputFiles && { outputFiles })), { suspiciousFilesResults,
        suspiciousGitDiffResults,
        suspiciousGitLogResults,
        processedFiles,
        safeFilePaths, skippedFiles: allSkippedFiles });
    logMemoryUsage('Pack - End');
    return result;
});
//# sourceMappingURL=packager.js.map