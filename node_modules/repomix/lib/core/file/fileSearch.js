var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import fs from 'node:fs/promises';
import path from 'node:path';
import { globby } from 'globby';
import { minimatch } from 'minimatch';
import { defaultIgnoreList } from '../../config/defaultIgnore.js';
import { RepomixError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';
import { sortPaths } from './filePathSort.js';
import { checkDirectoryPermissions, PermissionError } from './permissionCheck.js';
const findEmptyDirectories = (rootDir, directories, ignorePatterns) => __awaiter(void 0, void 0, void 0, function* () {
    const emptyDirs = [];
    for (const dir of directories) {
        const fullPath = path.join(rootDir, dir);
        try {
            const entries = yield fs.readdir(fullPath);
            const hasVisibleContents = entries.some((entry) => !entry.startsWith('.'));
            if (!hasVisibleContents) {
                // This checks if the directory itself matches any ignore patterns
                const shouldIgnore = ignorePatterns.some((pattern) => minimatch(dir, pattern) || minimatch(`${dir}/`, pattern));
                if (!shouldIgnore) {
                    emptyDirs.push(dir);
                }
            }
        }
        catch (error) {
            logger.debug(`Error checking directory ${dir}:`, error);
        }
    }
    return emptyDirs;
});
// Check if a path is a git worktree reference file
const isGitWorktreeRef = (gitPath) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const stats = yield fs.stat(gitPath);
        if (!stats.isFile()) {
            return false;
        }
        const content = yield fs.readFile(gitPath, 'utf8');
        return content.startsWith('gitdir:');
    }
    catch (_a) {
        return false;
    }
});
/**
 * Escapes special characters in glob patterns to handle paths with parentheses.
 * Example: "src/(categories)" -> "src/\\(categories\\)"
 */
export const escapeGlobPattern = (pattern) => {
    // First escape backslashes
    const escapedBackslashes = pattern.replace(/\\/g, '\\\\');
    // Then escape special characters () and [], but NOT {}
    return escapedBackslashes.replace(/[()[\]]/g, '\\$&');
};
/**
 * Normalizes glob patterns by removing trailing slashes and ensuring consistent directory pattern handling.
 * Makes "**\/folder", "**\/folder/", and "**\/folder/**\/*" behave identically.
 *
 * @param pattern The glob pattern to normalize
 * @returns The normalized pattern
 */
export const normalizeGlobPattern = (pattern) => {
    // Remove trailing slash but preserve patterns that end with "**/"
    if (pattern.endsWith('/') && !pattern.endsWith('**/')) {
        return pattern.slice(0, -1);
    }
    // Convert **/folder to **/folder/** for consistent ignore pattern behavior
    if (pattern.startsWith('**/') && !pattern.includes('/**')) {
        return `${pattern}/**`;
    }
    return pattern;
};
// Get all file paths considering the config
export const searchFiles = (rootDir, config, explicitFiles) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    // Check if the path exists and get its type
    let pathStats;
    try {
        pathStats = yield fs.stat(rootDir);
    }
    catch (error) {
        if (error instanceof Error && 'code' in error) {
            const errorCode = error.code;
            if (errorCode === 'ENOENT') {
                throw new RepomixError(`Target path does not exist: ${rootDir}`);
            }
            if (errorCode === 'EPERM' || errorCode === 'EACCES') {
                throw new PermissionError(`Permission denied while accessing path. Please check folder access permissions for your terminal app. path: ${rootDir}`, rootDir, errorCode);
            }
            // Handle other specific error codes with more context
            throw new RepomixError(`Failed to access path: ${rootDir}. Error code: ${errorCode}. ${error.message}`);
        }
        // Preserve original error stack trace for debugging
        const repomixError = new RepomixError(`Failed to access path: ${rootDir}. Reason: ${error instanceof Error ? error.message : JSON.stringify(error)}`);
        repomixError.cause = error;
        throw repomixError;
    }
    // Check if the path is a directory
    if (!pathStats.isDirectory()) {
        throw new RepomixError(`Target path is not a directory: ${rootDir}. Please specify a directory path, not a file path.`);
    }
    // Now check directory permissions
    const permissionCheck = yield checkDirectoryPermissions(rootDir);
    if (((_a = permissionCheck.details) === null || _a === void 0 ? void 0 : _a.read) !== true) {
        if (permissionCheck.error instanceof PermissionError) {
            throw permissionCheck.error;
        }
        throw new RepomixError(`Target directory is not readable or does not exist. Please check folder access permissions for your terminal app.\npath: ${rootDir}`);
    }
    try {
        const { adjustedIgnorePatterns, ignoreFilePatterns } = yield prepareIgnoreContext(rootDir, config);
        logger.trace('Ignore patterns:', adjustedIgnorePatterns);
        logger.trace('Ignore file patterns:', ignoreFilePatterns);
        // Start with configured include patterns
        let includePatterns = config.include.map((pattern) => escapeGlobPattern(pattern));
        // If explicit files are provided, add them to include patterns
        if (explicitFiles) {
            if (explicitFiles.length === 0) {
                logger.warn('[stdin mode] No files received from stdin. Will search all files matching include patterns.');
            }
            else {
                logger.debug(`[stdin mode] Processing ${explicitFiles.length} explicit files`);
                logger.trace('[stdin mode] Explicit files (absolute):', explicitFiles);
                const relativePaths = explicitFiles.map((filePath) => {
                    const relativePath = path.relative(rootDir, filePath);
                    // Escape the path to handle special characters
                    return escapeGlobPattern(relativePath);
                });
                logger.trace('[stdin mode] Explicit files (relative, escaped):', relativePaths);
                logger.trace('[stdin mode] Include patterns before merge:', includePatterns);
                includePatterns = [...includePatterns, ...relativePaths];
                logger.debug(`[stdin mode] Total include patterns after merge: ${includePatterns.length}`);
            }
        }
        // If no include patterns at all, default to all files
        if (includePatterns.length === 0) {
            includePatterns = ['**/*'];
        }
        logger.trace('Include patterns with explicit files:', includePatterns);
        logger.trace('Ignore patterns:', adjustedIgnorePatterns);
        logger.trace('Ignore file patterns (for globby):', ignoreFilePatterns);
        logger.debug('[globby] Starting file search...');
        const globbyStartTime = Date.now();
        const filePaths = yield globby(includePatterns, Object.assign(Object.assign({}, createBaseGlobbyOptions(rootDir, config, adjustedIgnorePatterns, ignoreFilePatterns)), { onlyFiles: true })).catch((error) => {
            // Handle EPERM errors specifically
            const code = error === null || error === void 0 ? void 0 : error.code;
            if (code === 'EPERM' || code === 'EACCES') {
                throw new PermissionError(`Permission denied while scanning directory. Please check folder access permissions for your terminal app. path: ${rootDir}`, rootDir);
            }
            throw error;
        });
        const globbyElapsedTime = Date.now() - globbyStartTime;
        logger.debug(`[globby] Completed in ${globbyElapsedTime}ms, found ${filePaths.length} files`);
        let emptyDirPaths = [];
        if (config.output.includeEmptyDirectories) {
            logger.debug('[empty dirs] Searching for empty directories...');
            const emptyDirStartTime = Date.now();
            const directories = yield globby(includePatterns, Object.assign(Object.assign({}, createBaseGlobbyOptions(rootDir, config, adjustedIgnorePatterns, ignoreFilePatterns)), { onlyDirectories: true }));
            const emptyDirElapsedTime = Date.now() - emptyDirStartTime;
            logger.debug(`[empty dirs] Found ${directories.length} directories in ${emptyDirElapsedTime}ms`);
            const filterStartTime = Date.now();
            emptyDirPaths = yield findEmptyDirectories(rootDir, directories, adjustedIgnorePatterns);
            const filterTime = Date.now() - filterStartTime;
            logger.debug(`[empty dirs] Filtered to ${emptyDirPaths.length} empty directories in ${filterTime}ms`);
        }
        logger.debug(`[result] Total files: ${filePaths.length}, empty directories: ${emptyDirPaths.length}`);
        logger.trace(`Filtered ${filePaths.length} files`);
        return {
            filePaths: sortPaths(filePaths),
            emptyDirPaths: sortPaths(emptyDirPaths),
        };
    }
    catch (error) {
        // Re-throw PermissionError as is
        if (error instanceof PermissionError) {
            throw error;
        }
        if (error instanceof Error) {
            logger.error('Error filtering files:', error.message);
            throw new Error(`Failed to filter files in directory ${rootDir}. Reason: ${error.message}`);
        }
        logger.error('An unexpected error occurred:', error);
        throw new Error('An unexpected error occurred while filtering files.');
    }
});
export const parseIgnoreContent = (content) => {
    if (!content)
        return [];
    return content.split('\n').reduce((acc, line) => {
        const trimmedLine = line.trim();
        if (trimmedLine && !trimmedLine.startsWith('#')) {
            acc.push(trimmedLine);
        }
        return acc;
    }, []);
};
/**
 * Prepares ignore context including patterns and file patterns with git worktree handling.
 * This logic is shared across searchFiles, listDirectories, and listFiles.
 *
 * @param rootDir The root directory to search
 * @param config The merged configuration
 * @returns Object containing adjusted ignore patterns and ignore file patterns
 */
const prepareIgnoreContext = (rootDir, config) => __awaiter(void 0, void 0, void 0, function* () {
    const [ignorePatterns, ignoreFilePatterns] = yield Promise.all([
        getIgnorePatterns(rootDir, config),
        getIgnoreFilePatterns(config),
    ]);
    // Normalize ignore patterns to handle trailing slashes consistently
    const normalizedIgnorePatterns = ignorePatterns.map(normalizeGlobPattern);
    // Check if .git is a worktree reference
    const gitPath = path.join(rootDir, '.git');
    const isWorktree = yield isGitWorktreeRef(gitPath);
    // Modify ignore patterns for git worktree
    const adjustedIgnorePatterns = [...normalizedIgnorePatterns];
    if (isWorktree) {
        // Remove '.git/**' pattern and add '.git' to ignore the reference file
        const gitIndex = adjustedIgnorePatterns.indexOf('.git/**');
        if (gitIndex !== -1) {
            adjustedIgnorePatterns.splice(gitIndex, 1);
            adjustedIgnorePatterns.push('.git');
        }
    }
    return { adjustedIgnorePatterns, ignoreFilePatterns };
});
/**
 * Creates base globby options with common ignore patterns.
 * Returns options that can be extended with specific settings like onlyFiles or onlyDirectories.
 */
const createBaseGlobbyOptions = (rootDir, config, ignorePatterns, ignoreFilePatterns) => ({
    cwd: rootDir,
    ignore: ignorePatterns,
    gitignore: config.ignore.useGitignore,
    ignoreFiles: ignoreFilePatterns,
    absolute: false,
    dot: true,
    followSymbolicLinks: false,
});
export const getIgnoreFilePatterns = (config) => __awaiter(void 0, void 0, void 0, function* () {
    const ignoreFilePatterns = [];
    // Note: When ignore files are found in nested directories, files in deeper
    // directories have higher priority, following the behavior of ripgrep and fd.
    // For example, `src/.ignore` patterns override `./.ignore` patterns.
    //
    // Multiple ignore files in the same directory (.gitignore, .ignore, .repomixignore)
    // are all merged together. The order in this array does not affect priority.
    //
    // .gitignore files are handled by globby's gitignore option (not ignoreFiles)
    // to properly respect parent directory .gitignore files, matching Git's behavior.
    if (config.ignore.useDotIgnore) {
        ignoreFilePatterns.push('**/.ignore');
    }
    ignoreFilePatterns.push('**/.repomixignore');
    return ignoreFilePatterns;
});
export const getIgnorePatterns = (rootDir, config) => __awaiter(void 0, void 0, void 0, function* () {
    const ignorePatterns = new Set();
    // Add default ignore patterns
    if (config.ignore.useDefaultPatterns) {
        logger.trace('Adding default ignore patterns');
        for (const pattern of defaultIgnoreList) {
            ignorePatterns.add(pattern);
        }
    }
    // Add repomix output file
    if (config.output.filePath) {
        const absoluteOutputPath = path.resolve(config.cwd, config.output.filePath);
        const relativeToTargetPath = path.relative(rootDir, absoluteOutputPath);
        logger.trace('Adding output file to ignore patterns:', relativeToTargetPath);
        ignorePatterns.add(relativeToTargetPath);
    }
    // Add custom ignore patterns
    if (config.ignore.customPatterns) {
        logger.trace('Adding custom ignore patterns:', config.ignore.customPatterns);
        for (const pattern of config.ignore.customPatterns) {
            ignorePatterns.add(pattern);
        }
    }
    // Add patterns from .git/info/exclude if useGitignore is enabled
    if (config.ignore.useGitignore) {
        // Read .git/info/exclude file
        const excludeFilePath = path.join(rootDir, '.git', 'info', 'exclude');
        try {
            const excludeFileContent = yield fs.readFile(excludeFilePath, 'utf8');
            const excludePatterns = parseIgnoreContent(excludeFileContent);
            for (const pattern of excludePatterns) {
                ignorePatterns.add(pattern);
            }
        }
        catch (error) {
            // File might not exist or might not be accessible, which is fine
            logger.trace('Could not read .git/info/exclude file:', error instanceof Error ? error.message : String(error));
        }
    }
    return Array.from(ignorePatterns);
});
/**
 * Lists all directories in the given root directory, respecting ignore patterns.
 * This function does not apply include patterns - it returns the full directory set subject to ignore rules.
 *
 * @param rootDir The root directory to scan
 * @param config The merged configuration
 * @returns Array of directory paths relative to rootDir
 */
export const listDirectories = (rootDir, config) => __awaiter(void 0, void 0, void 0, function* () {
    const { adjustedIgnorePatterns, ignoreFilePatterns } = yield prepareIgnoreContext(rootDir, config);
    const directories = yield globby(['**/*'], Object.assign(Object.assign({}, createBaseGlobbyOptions(rootDir, config, adjustedIgnorePatterns, ignoreFilePatterns)), { onlyDirectories: true }));
    return sortPaths(directories);
});
/**
 * Lists all files in the given root directory, respecting ignore patterns.
 * This function does not apply include patterns - it returns the full file set subject to ignore rules.
 *
 * @param rootDir The root directory to scan
 * @param config The merged configuration
 * @returns Array of file paths relative to rootDir
 */
export const listFiles = (rootDir, config) => __awaiter(void 0, void 0, void 0, function* () {
    const { adjustedIgnorePatterns, ignoreFilePatterns } = yield prepareIgnoreContext(rootDir, config);
    const files = yield globby(['**/*'], Object.assign(Object.assign({}, createBaseGlobbyOptions(rootDir, config, adjustedIgnorePatterns, ignoreFilePatterns)), { onlyFiles: true }));
    return sortPaths(files);
});
//# sourceMappingURL=fileSearch.js.map