var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { initTaskRunner } from '../../shared/processConcurrency.js';
import { buildSplitOutputFilePath } from '../output/outputSplit.js';
import { calculateGitDiffMetrics } from './calculateGitDiffMetrics.js';
import { calculateGitLogMetrics } from './calculateGitLogMetrics.js';
import { calculateOutputMetrics } from './calculateOutputMetrics.js';
import { calculateSelectiveFileMetrics } from './calculateSelectiveFileMetrics.js';
export const calculateMetrics = (processedFiles_1, output_1, progressCallback_1, config_1, gitDiffResult_1, gitLogResult_1, ...args_1) => __awaiter(void 0, [processedFiles_1, output_1, progressCallback_1, config_1, gitDiffResult_1, gitLogResult_1, ...args_1], void 0, function* (processedFiles, output, progressCallback, config, gitDiffResult, gitLogResult, deps = {
    calculateSelectiveFileMetrics,
    calculateOutputMetrics,
    calculateGitDiffMetrics,
    calculateGitLogMetrics,
    taskRunner: undefined,
}) {
    var _a;
    progressCallback('Calculating metrics...');
    // Initialize a single task runner for all metrics calculations
    const taskRunner = (_a = deps.taskRunner) !== null && _a !== void 0 ? _a : initTaskRunner({
        numOfTasks: processedFiles.length,
        workerType: 'calculateMetrics',
        runtime: 'worker_threads',
    });
    try {
        const outputParts = Array.isArray(output) ? output : [output];
        // For top files display optimization: calculate token counts only for top files by character count
        // However, if tokenCountTree is enabled, calculate for all files to avoid double calculation
        const topFilesLength = config.output.topFilesLength;
        const shouldCalculateAllFiles = !!config.output.tokenCountTree;
        // Determine which files to calculate token counts for:
        // - If tokenCountTree is enabled: calculate for all files to avoid double calculation
        // - Otherwise: calculate only for top files by character count for optimization
        const metricsTargetPaths = shouldCalculateAllFiles
            ? processedFiles.map((file) => file.path)
            : [...processedFiles]
                .sort((a, b) => b.content.length - a.content.length)
                .slice(0, Math.min(processedFiles.length, Math.max(topFilesLength * 10, topFilesLength)))
                .map((file) => file.path);
        const [selectiveFileMetrics, outputTokenCounts, gitDiffTokenCount, gitLogTokenCount] = yield Promise.all([
            deps.calculateSelectiveFileMetrics(processedFiles, metricsTargetPaths, config.tokenCount.encoding, progressCallback, { taskRunner }),
            Promise.all(outputParts.map((part, index) => __awaiter(void 0, void 0, void 0, function* () {
                const partPath = outputParts.length > 1
                    ? buildSplitOutputFilePath(config.output.filePath, index + 1)
                    : config.output.filePath;
                return yield deps.calculateOutputMetrics(part, config.tokenCount.encoding, partPath, { taskRunner });
            }))),
            deps.calculateGitDiffMetrics(config, gitDiffResult, { taskRunner }),
            deps.calculateGitLogMetrics(config, gitLogResult, { taskRunner }),
        ]);
        const totalTokens = outputTokenCounts.reduce((sum, count) => sum + count, 0);
        const totalFiles = processedFiles.length;
        const totalCharacters = outputParts.reduce((sum, part) => sum + part.length, 0);
        // Build character counts for all files
        const fileCharCounts = {};
        for (const file of processedFiles) {
            fileCharCounts[file.path] = file.content.length;
        }
        // Build token counts only for top files
        const fileTokenCounts = {};
        for (const file of selectiveFileMetrics) {
            fileTokenCounts[file.path] = file.tokenCount;
        }
        return {
            totalFiles,
            totalCharacters,
            totalTokens,
            fileCharCounts,
            fileTokenCounts,
            gitDiffTokenCount: gitDiffTokenCount,
            gitLogTokenCount: gitLogTokenCount.gitLogTokenCount,
        };
    }
    finally {
        // Cleanup the task runner after all calculations are complete (only if we created it)
        if (!deps.taskRunner) {
            yield taskRunner.cleanup();
        }
    }
});
//# sourceMappingURL=calculateMetrics.js.map